---
title: Redis之开篇必读
date: 2019-11-27 16:40:56
tags: [redis]
categories: [redis]
keywords: redis
toc: ture
description: "&emsp;&emsp;Redis是一个由Salvatore Sanfilippo写的key-value存储系统，是一个开源的使用 ANSI C语言编写、遵守BSD协议、支持
网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API，它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈
希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。使用之前我们必须了解为什么而使用。"
---

# Redis 与其他 key - value 缓存产品比较
   * Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
   * Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
   * Redis支持数据的备份，即master-slave模式的数据备份。
   
# Redis 优势
   * 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
   * 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
   * 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和E
   XEC指令包起来。
   * 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。
   
# Redis与其他key-value存储有什么不同
   * Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，
无需进行额外的抽象。
   * Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相
比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生
的，因为他们并不需要进行随机访问。

# redis 特性
   * 速度快
       + Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）；
       + 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
       + 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
       + 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操
        作，没有因为可能出现死锁而导致的性能消耗；
       + 使用多路I/O复用模型，非阻塞IO；
       + 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，
       会浪费一定的时间去移动和请求；
   * 持久化
       + RDB：在指定的时间间隔能对你的数据进行快照存储。
            - 机制：
                    在Redis运行时，RDB程序将当前内存中的数据库快照保存到磁盘文件中，在Redis重启动时，RDB程序可以通过载入RDB文件来还原数据库的
                   状态。RDB机制最主要的就是rdbSave和rdbLoad函数，前者将redis内存中数据加载到磁盘上，后者将在Redis重启时将数据恢复到redis
                   内存中，注意rdbSave会阻塞主进程。
            - 优势：
                    一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这样非常方便进行备份。比如你可能打算没1天归档一些数据。
                     方便备份，我们可以很容易的将一个一个RDB文件移动到其他的存储介质上
                    - RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
                    - RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有
                    保存工作，父进程无须执行任何磁盘操作。
            - 劣势：
                    如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 
                    文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 
                    文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，
                    并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据
                    集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 
                    重写的执行间隔有多长，数据的耐久性都不会有任何损失
                    
       + AOF: 记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据
            - 机制：
                    AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到AOF文件，以此达到记录数据库状态的目的。AOF文件其实可以
                    认为是Redis写操作的日志记录文件。
                    - 具体过程：
                    - redis调用fork ，现在有父子两个进程
                    - 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令
                    - 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。
                    - 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。
                    - 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加
                    - （注意到是重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件）
            - 优势：
                    使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一
                    次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的
                    性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。
            - 劣势：
                    对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 
                   在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。
                     不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）
       +（有待实践）
  
   + 多种数据结构
       + String（字符串）/Blobs/Bitmaps（位图）
       + Hash Tables（哈希）
       + Linked Lists（列表）
       + Sets（集合）
       + Sorted Sets（有序集合）
   + 主从复制（后续更新）
   + 高可用、分布式
